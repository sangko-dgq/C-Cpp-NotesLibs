### **C语言中的关键字**

##### C语言中的关键字按照**功能**分为：

- 数据类型(常用有：char, short, int, long, )
-  运算和表达式（=， +， - ， *， while, do-while, if, goto, switch-case）
- 数据存储（auto, static, extern, const, register, volatile, restricted）
- 结构（strut, enum,union, typedef）
- 位操作和逻辑运算（<<, >>, &, |, ~, ^, &&）
- 预处理（#define, #include, #error, #if...#else...#endif等）
- 平台扩展关键字（ _ _asm, _ _inline, _ _syscall）

关键字共同构成了嵌入式的C语法。

##### 嵌入式的应用从逻辑上抽象为三个部分：

- 数据的输入（t如传感器，信号，接口输入等）
- 数据的处理 （如协议的解码和封包，AD采样值的转换等）
- 数据的输出 （如GUI的显示，输出的引脚状态，DA的输出控制电压，PWM的波的占空比等）

数据的管理贯穿着整个嵌入式应用，包含数据类型，存储空间的管理，位和逻辑操作，以及数据结构。

C语言从语法上支撑上述功能的实现，并且提供了相应的优化机制，以应对嵌入式下受限的资源环境。



### 数据类型

C语言支持常用的字符型，整型，浮点型变量，有些编译器如keil还扩展支持bit(位)和sfr(寄存器)等数据类型来满足特殊的地址操作。

C语言只规定了每种基本数据类型的**最小取值范围**，因此在不同芯片平台上相同类型可能占用不同长度的存储空间（比如Arduino和ESP32芯片不同），这就需要在代码实现时考虑后续移植的兼容性。

而C语言提供的typedef就是用于处理这种情况的关键字，在大部分支持跨平台的软件项目中被采用，典型如下：

```c
typedef unsigned char uint8_t;
...
```

既然不同平台的基本数据的宽度不一致，那么如何确定当前平台的基础数据类型如int的宽度，这就需要C语言提供的接口sizeof，实现如下。

```c
printf("int size:%d\n", sizeof(int));
```

   指针的宽度

```c
char *p;
printf("point p size:%d\n", sizeof(p));
```

 这将和芯片的可寻址宽度有关，如:32位的MCU的宽度宽度为4,64位的宽度是8，因此，有时候也这也是查看MCU位宽比较简单的方式。

### 内存管理和存储架构

C语言允许程序变量在定义时就确定内存地址，通过作用域，以及关键字extern, static,实现了精细的处理机制，按照在硬件的区域不同，内存分配有三种方式：

- 从**静态存储区**域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间就存在。例如 全局变量，static变量。
- 在**栈**上创建。在执行函数的时，**函数内局部变量**的存储单元都可以在栈上创建，函数执行结束时这些存储单元会自动释放。栈内存分配运算内置于处理器的指令集，**效率很高**，但是分配的内存**容量有限**。
- 从**堆**上分配，也称为**动态内存**分配。程序在运行的时候用malloc或new申请任意多大的内存，程序员自己负责在何时调用free或delete来释放内存。动态内存的生存期由程序员决定，使用非常灵活，但同时遇到的问题也会相对最多。

示例：

```c
#include <stdio.h>
#include <stdlib.h>

static int v1; // 静态全局变量 - 静态存储区
int v2;        // 全局变量 - 静态存储区

int main(void)
{
    static int a1 = 0;   // 静态局部变量 - 栈上申请
    int a2 = 0;      // 局部变量 -  栈上申请
    int *ptr_a3 = NULL; // 指针变量 - 栈上申请
    ptr_a3 = (int *)malloc(sizeof(int)); // malloc - 堆上申请动态空间
    if(ptr_a3 != NULL)
    {
        free(ptr_a3); // 释放堆上申请的空间  
        ptr_a3 = NULL;
    }
    

}
```

可见，C语言的作用域不仅描述了标识符的可访问区域，其实也规定了变量的存储区域。

其中，static关键字主要限定变量能否被其他文件访问，而代码块的作用域中的变量需要根据类型的不同，分配到不同的区域。

static在文件作用域和代码块的意义时不同的，在文件作用域用于限定函数和变量的外部连接性（能否被外部其他文件访问），在代码块的作用是将变量分配到静态存储区域。



相对于普通C语言，嵌入式C方面，定义一个变量，他不一定在**内存（SRAM）**中，也可能在**FLASH**空间中，也可能直接由寄存器存储（rigister定义变量或者高优化等级下的部分局部变量），如定义为const的全局变量定义在FLASH中，定义为register的局部变量会被优化到直接放在**通用寄存器**中。

在需要优化程序运行速度或者当发生存储受限的情况下，理解这部分知识对于代码的维护很有参考意义。

此外，嵌入式C语言的编译器会扩展内存管理机制，如支持分散加载机制和  _ _attribute_ _ ((section("用户定义区域")))，允许指定变量存储在特殊的区域（如：SDRAM， SQI FLASH等） ，这强化了内存的管理，以适应复杂的应用环境场景和需求。

```c

LD_ROM 0x00800000 0x10000 { ;load region size_region
    EX_ROM 0x00800000 0x10000 { ;load address = execution address
  *.o (RESET, +First)
  *(InRoot$$Sections)
  .ANY (+RO)
  }
  EX_RAM 0x20000000 0xC000 { ;rw Data
    .ANY (+RW +ZI)
  }
  EX_RAM1 0x2000C000 0x2000 {
    .ANY(MySection)
   }
  EX_RAM2 0x40000000 0x20000{
    .ANY(Sdram)
  }
}

int a[10] __attribute__((section("Mysection")));
int b[100] __attribute__((section("Sdram")));
```

采用这种方式，我们可以将变量指定到需要的区域，这在某些情况下是必须的。比如在做GUI或者网页的时候需要存储大量的图片和文档，内部的FLASH空间是有限的的，这时候可以将对应的变量声明到外部区域，另外，内存中的某些部分的数据比较重要，为了避免被其他内容覆盖，可能需要单独划分SRAM区域，避免被误修改导致致命性的错误。这些经验在实际的产品开发中是常用且重要的。

对于堆得使用，对于嵌入式Linux来说，使用和标准C语言一致，注意malloc后要检查，记得**释放**且后**置空**，避免“野指针”。

```c
int *ptr_a3 = NULL; 
ptr_a3 = (int *)malloc(sizeof(int)); 
if(ptr_a3 != NULL)
{
    free(ptr_a3); // 释放堆上申请的空间  
    ptr_a3 = NULL;// 置空
}
```

不过对于资源比较受限的单片机来说，使用malloc的场景一般比较少，如果需要频繁地申请内存块的场景，都会单独构建基于静态存储区和内存块分割的一套内存管理机制，这样做，一方面效率会比较高（用固定大小的块提前分割，在使用的时候直接查找编号处理），另一方面对于内存块的使用可控，可以有效避免内存碎片的问题，常见的如RTOS和网络LWIP都是采用这种机制。

### 指针和数组

指针和数组往往是引起程序bug的主要原因，比如数组越界，指针越界，非法地址访问，非对齐访问等。

数组和指针的基本概念理解这里省略。

数组是由相同类型元素构成的，当他被声明时，编译器就会根据内部元素的特性在内存中分配一段空间，另外C语言也提供多维数组，以应对特殊场景的需求，而指针则是提供使用地址符号的方法，只有指向具体的地址才有意义，C语言的指针具有最大的灵活性，在被访问前，可以指向任何的地址，这大大方便了对硬件的操作，但同时也对开发者有了更高的要求。

如果数组过大，会导致数组超过时无法截止，从而陷入死循环。

由于，**指针占用的空间与芯片的寻址宽度有关系，32位平台位4个字节，64位平台为8个字节，**而指针的加减运算的长度又与他的类型相关，如char类型为1，int为4。

另外，指针还支持强制转换，在某些情况下相当有用。

基于指针的强制转换，在协议解析，数据存储管理中高效快捷地解决了数据解析的问题，但是，在处理过程中涉及的数据对齐，大小端，都是常见且十分易错的问题。

volatile易变的，可变的，一般用于以下几种状况：

- 并行设备的硬件寄存器，如：状态寄存器
- 一个中断服务子程序中会访问到的非自动变量（Non-automatic variables）
- 多线程应用中被几个任务共享的变量

volatile可以解决用户模式和异常中断访问同一个变量时，出现不同步的问题，另外在访问硬件地址时，volatile也阻止对地址访问的优化，从而确保访问实际的地址。

精通volatile的运用，在嵌入式底层中十分重要。

函数指针在一般嵌入式软件的开发中并不常见，但对于许多重要的实现如异步回调，驱动模块等，使用函数指针就可以利用简单的方式实现很多应用。

### 结构类型和对齐

C语言提供自定义数据类型来描述一类具有相同特征点的事务，主要支持的有结构体，枚举和联合体。其中枚举通过别名限制数据的访问，可以时数据更加直观易读，实现如下：

```c
typedef enum {a = 1, b, c} number;
number n1 = b;
```

联合体的是能在同一存储空间里存储不同数据类型的数据类型，对于联合体的占用空间，则是以其中**占用空间最大的变量为准**。

联合体的用途主要通过共享内存地址的方式，实现对数据内部段的访问，这在解析某些变量时，提供了更为简便的方式，此外测试芯片的大小端模式也是联合体的常见应用，当然利用指针强制转换，

结构体则是将具有共通特征的变量组成的集合，比起C++的类来说，它没有安全访问的限制，不支持直接内部带函数，但通过自定义数据类型，函数指针，仍然能够实现很多类似于类的操作，

对于大部分嵌入式项目来说，结构化处理数据对于优化整体架构以及后期维护大有便利。

C语言的结构体支持指针和变量的方式访问，通过转换可以解析任意内存的数据，如我们之前提到的通过指针强制转换解析协议。

另外通过将数据和函数指针打包，在通过指针传递，是实现驱动层实接口切换的重要基础，有着重要的实践意义，另外基于位域，联合体，结构体，可以实现另一种位操作，这对于封装底层硬件寄存器具有重要意义。

通过联合体和位域操作，可以实现对数据内bit的访问，这在寄存器以及内存受限的平台，提供了简便且直观的处理方式，

另外对于结构体的另一个重要知识点就是对齐了，通过对齐访问，可以大幅度提高运行效率，但是因为对齐引入的存储长度问题，也是容易出错的问题，对于对齐的理解，可以分类为如下说明。

- 基础数据类型：以默认的的长度对齐，如char以1字节对齐，short以2字节对齐等
- 数组 ：按照基本数据类型对齐，第一个对齐了后面的自然也就对齐了。
- 联合体 ：按其包含的长度最大的数据类型对齐。
- 结构体：结构体中每个数据类型都要对齐，结构体本身以内部最大数据类型长度对齐

其中union联合体的大小与内部最大的变量int一致，为4字节，根据读取的值，就知道实际内存布局和填充的位置是一致，事实上学会通过填充来理解C语言的对齐机制，是有效且快捷的方式。

### 预处理机制

C语言提供了丰富的预处理机制，方便了跨平台的代码的实现，此外C语言通过宏机制实现的数据和代码块替换，字符串格式化，代码段切换，对于工程应用具有重要意义，下面按照功能需求，描述在C语言运用中的常用预处理机制。

\#define宏定义，常见的用法包含定义常量或者代码段别名，当然某些情况下配合##格式化字符串，可以实现接口的统一化处理，

\#if..#elif...#else...#endif， #ifdef..#endif, #ifndef...#endif条件选择判断，条件选择主要用于切换代码块，这种综合性项目和跨平台项目中为了满足多种情况下的需求往往会被使用。

\#undef 取消定义的参数，避免重定义问题。

\#error，#warning用于用户自定义的告警信息，配合#if，#ifdef使用，可以限制错误的预定义配置。

\#pragma 带参数的预定义处理，常见的#pragma pack(1), 不过使用后会导致后续的整个文件都以设置的字节对齐，配合push和pop可以解决这种问题，代码如下：

```c
#pragma pack(push)
#pragma pack(1)
struct TestA
{
char i;
int b;
}A;
#pragma pack(pop); //注意要调用pop，否则会导致后续文件都以pack定义值对齐，执行不符合预期
//等同于
struct _TestB{
char i;
int b;
 }__attribute__((packed))A;
```



嵌入式C语言在处理硬件物理地址、位操作、内存访问方面都给予开发者了充分的自由。[STM32开发中的位运算以及位带操作](http://mp.weixin.qq.com/s?__biz=MzI1MDg4OTMwMw==&mid=2247490874&idx=1&sn=492695b952f96fc28b4e0d46f9dad9ae&chksm=e9fa0802de8d8114c9749b88da6575394dec63735cb365e56ffc0542c7577b0962abc1fb7ce4&scene=21#wechat_redirect)。

通过数组，指针以及强制转换的技巧，可以有效减少数据处理中的复制过程，这对于底层是必要的，也方便了整个架构的开发。